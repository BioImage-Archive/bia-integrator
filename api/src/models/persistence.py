from enum import Enum
from pydantic import BaseModel, Field, BaseConfig
from typing import Dict, List, Optional, Union, AnyStr
from pathlib import Path
from ome_types import OME, from_xml
from urllib.parse import urlparse, urlunparse
from bson import ObjectId, errors
from uuid import UUID
import requests
import datetime

class BIABaseModel(BaseModel):
    def json(self, ensure_ascii=False, **kwargs):
        """ensure_ascii defaults to False instead of True to handle the common case of non-ascii names"""

        return super().json(ensure_ascii=ensure_ascii, **kwargs)

class OID(str):
  @classmethod
  def __get_validators__(cls):
      yield cls.validate

  @classmethod
  def validate(cls, v):
      try:
          return ObjectId(str(v))
      except errors.InvalidId:
          raise ValueError("Not a valid ObjectId")

class DocumentMixin(BaseModel):
    _id: OID = Field()
    uuid: UUID = Field()
    version: int = Field()

    @property
    def mongo_oid(self) -> OID:
        return self._id

    class Config(BaseConfig):
        allow_population_by_field_name = True
        json_encoders = {
            #datetime: lambda dt: dt.isoformat(),
            #ObjectId: lambda oid: str(oid)
        }

class Author(BIABaseModel):
    name: str

class AnnotationState(str, Enum):
    active = "active",
    deleted = "deleted"

class Annotation(BIABaseModel):
    author_email: str
    key: str
    value: str
    state: AnnotationState

class ImageAnnotation(Annotation):
    pass

class StudyAnnotation(Annotation):
    pass

class BIAStudy(BIABaseModel, DocumentMixin):
    title: str = Field()
    description: str = Field()
    authors: Optional[List[Author]] = Field(default=[])
    organism: str = Field()
    release_date: str = Field()
    
    imaging_type: List[str] = Field(default=[])
    attributes: Dict = Field(default={})
    annotations: List[StudyAnnotation] = Field(default=[])
    example_image_uri: str = Field(default="")
    tags: List[str] = Field(default=[])

    file_references_count: int = Field(default=0)
    images_count: int = Field(default=0)

class FileReference(BIABaseModel, DocumentMixin):
    """A reference to an externally hosted file."""

    study_uuid: UUID = Field()
    name: str # A short descriptive name
    uri: str # URI of the file
    size_bytes: Optional[int] # Size of the file
    attributes: Dict = {}

class ChannelRendering(BIABaseModel):
    colormap_start: List[float]
    colormap_end: List[float]
    scale_factor: float = 1.0

class RenderingInfo(BIABaseModel):
    channel_renders: List[ChannelRendering]
    default_z: Optional[int]
    default_t: Optional[int]

class BIAImageAlias(BIABaseModel):
    """An alias for an image - a more convenient way to refer to the image than
    the full accession ID / UUID pair"""

    name: str
    accession_id: str
    
class BIAImageRepresentation(BIABaseModel):
    """A particular representation of a BIAImage. Examples:
    
    * A single HTTP accessible file.
    * Multiple HTTP accessible files, representing different channels, planes and time points.
    * An S3 accessible OME-Zarr.
    * A thumbnail."""
    
    image: UUID = Field()
    accession_id: str = Field()
    size: int = Field()
    uri: List[str] = Field(default=[])
    type: Optional[str] = Field(default=None)
    dimensions: Optional[str] = Field(default=None)
    attributes: Dict = Field(default={})
    rendering: Optional[RenderingInfo] = Field(default=None)

class BIAOmeMetadata(dict):
    pass

class BIAImage(BIABaseModel, DocumentMixin):
    """This class represents the abstract concept of an image. Images are
    generated by acquisition by instruments.

    Examples:

    * A single plane bright-field image of a bacterium.
    * A confocal fluorescence image of cells, with two channels.
    * A volume EM stack of a cell.

    Images are distinct from their representation as files, since the same
    image can be represented in different file formats and in some cases
    different file structures.
    """

    study_uuid: UUID = Field()
    original_relpath: str = Field() # originally Path
    name: Optional[str] = Field(default=None)

    dimensions: Optional[str] = Field(default=None)
    representations: List[BIAImageRepresentation] = Field(default=[])
    attributes: Dict = Field(default={})
    annotations: List[ImageAnnotation] = Field(default=[])
    image_aliases: List[BIAImageAlias] = Field(default=[])

    @property
    def ome_metadata(self) -> Optional[BIAOmeMetadata]:
        metadata = self.__dict__.get('ome_metadata', None)
        if metadata is None:
            ngff_rep = [rep for rep in self.representations if rep.type == "ome_ngff"]
            if not ngff_rep:
                return None
            else:
                # If the same image has multiple ngff representations, assume metadata is the same
                ngff_rep = ngff_rep.pop()
                parsed_url = urlparse(ngff_rep.uri)
                ome_metadata_path = Path(parsed_url.path).parent/"OME/METADATA.ome.xml"
                ome_metadata_uri = urlunparse((
                    parsed_url.scheme, parsed_url.netloc, str(ome_metadata_path),
                    None,
                    None,
                    None
                ))

                metadata = BIAImage._ome_xml_url_parse(ome_metadata_uri)
                self.__dict__['ome_metadata'] = metadata

        return metadata

    @classmethod
    def _ome_xml_url_parse(cls, ome_metadata_uri: AnyStr) -> Optional[OME]:    
        r = requests.get(ome_metadata_uri)
        assert r.status_code == 200, f"Error {r.status_code} fetching URI '{ome_metadata_uri}: {r.content}"

        ome_metadata = from_xml(r.content, parser='lxml', validate=False)

        return ome_metadata

class BIACollection(BIABaseModel, DocumentMixin):
    """A collection of studies with a coherent purpose. Studies can be in 
    multiple collections."""
    name: str
    title: str
    subtitle: str
    description: Optional[str]
    accession_ids: List[str]
