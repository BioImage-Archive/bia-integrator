from typing import Dict, List, Optional

import zarr
import numpy as np
import dask.array as da
from PIL import Image
from pydantic import BaseModel
from microfilm.colorify import multichannel_to_rgb
from matplotlib.colors import LinearSegmentedColormap


DEFAULT_COLORS = [
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1],
    [0, 1, 1],
    [1, 0, 1],
    [1, 1, 0]
]

DEFAULT_COLORMAPS = [
    LinearSegmentedColormap.from_list(f'n{n}', ([0, 0, 0], cmap_end))
    for n, cmap_end in enumerate(DEFAULT_COLORS)
]


class ChannelRenderingSettings(BaseModel):
    """Rendering settings for a specific channel."""

    label: Optional[str]
    colormap_start: List[float] = [0., 0., 0.]
    colormap_end: List[float]
    window_start: Optional[int]
    window_end: Optional[int]


# FIXME - naming
class PlaneRegionSelection(BaseModel):
    """A 2D rectangular region."""

    t: int
    z: int
    c: int
    xmin: int
    xmax: int
    ymin: int
    ymax: int


class RenderingView(BaseModel):
    """A view of a BIAImage that should provide settings to produce a 2D image.
    
    Used for, e.g., generating thumbnails or example images."""

    t: int = 0
    z: int = 0
    region: Optional[PlaneRegionSelection]

    channel_rendering: Dict[int, ChannelRenderingSettings]


def scale_to_uint8(array):
    """Given an input array, convert to uint8, including scaling to fill the
    0-255 range. 
    
    Primarily used to convert general numpy arrays into an image rendering
    suitable dtype."""

    scaled = array.astype(np.float32)

    if scaled.max() - scaled.min() == 0:
        return np.zeros(array.shape, dtype=np.uint8)

    scaled = 255 * (scaled - scaled.min()) / (scaled.max() - scaled.min())

    return scaled.astype(np.uint8)


def apply_window(array, window_start, window_end):
    """Apply a windowing function to the given array, values above or below
    the window are clipped to the edges, and the range is scaled to the
    window range."""
    
    scaled = (array - window_start) / (window_end - window_start)
    clipped = np.clip(scaled, 0, 1)
    
    return clipped


def generate_channel_renderings(n_channels):
    """Generate a list channel renderings for a number of channels."""

    threemap_ends = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
    ]

    channel_renderings = {
        n: ChannelRenderingSettings(colormap_end=colormap_end)
        for n, colormap_end in enumerate(threemap_ends)
    }

    return channel_renderings


def dask_array_from_ome_ngff_rep(ome_ngff_rep):
    """Get a dask array from an OME-NGFF image representation."""

    zgroup = zarr.open(ome_ngff_rep.uri)
    # FIXME - this should not be hard coded, it may break on spec-conformant images that are not generated by bioformats2raw
    path_key = '0'

    darray = da.from_zarr(zgroup[path_key])

    return darray


def best_efforts_render_image(accession_id, image_id):
    
    bia_proxy_im = BIAProxyImage(accession_id, image_id)

    t = bia_proxy_im.size_t // 2
    z = bia_proxy_im.size_z // 2
    
    region_per_channel = {
        c: PlaneRegionSelection(
            t=t,
            z=z,
            c=c,
            ymin=0,
            ymax=bia_proxy_im.size_y,
            xmin=0,
            xmax=bia_proxy_im.size_x
        )
        for c in range(bia_proxy_im.size_c)
    }

    darray = bia_proxy_im.darray

    channel_arrays = {c: select_region_from_dask_array(darray, region) for c, region in region_per_channel.items()}

#     channel_arrays = {c: apply_window(array, 0, 150) for c, array in channel_arrays.items()}

    cmaps = DEFAULT_COLORMAPS[:bia_proxy_im.size_c]

    im = render_multiple_2D_arrays(channel_arrays.values(), cmaps)
    
    return im


def render(ome_ngff_rep, rview: RenderingView) -> Image:
    """Given an OME NGFF representation, return a rendering."""

    darray = dask_array_from_ome_ngff_rep(ome_ngff_rep)

    assert len(darray.shape) == 5
    n_channels = darray.shape[1]

    z = 0
    t = 0
    if rview.region:
        s = np.s_[z, 0, t, rview.region.ymin:rview.region.ymax, rview.region.xmin:rview.region.xmax]
    else:
        s = np.s_[z, 0, t, :, :]
    
    arrays = [darray[s].compute() for n in range(n_channels)]
    # arrays = [darray[t, n, z, :, :].compute() for n in range(n_channels)]

    cmaps = [
        LinearSegmentedColormap.from_list(f'c{c}', (crendering.colormap_start, crendering.colormap_end))
        for c, crendering in rview.channel_rendering.items()
    ]

    imarray, _, _, _ = multichannel_to_rgb(arrays, cmaps)
    im = Image.fromarray(scale_to_uint8(imarray))

    return im

    # if rview.region:
    #     sections = {
    #         c: darray[rview.t, c, rview.z, rview.region.ymin:rview.region.ymax, rview.region.xmin:rview.region.xmax].compute()
    #         for c in rview.channel_rendering.keys()
    #     }
    # else:
    #      sections = {
    #         c: darray[rview.t, c, rview.z, :, :].compute()
    #         for c in rview.channel_rendering.keys()
    #     }       

    # windowed_sections = {}

    # for c, array in sections.items():
    #     if rview.channel_rendering[c].window_start:
    #         windowed_sections[c] = apply_window(array, rview.channel_rendering[c].window_start, rview.channel_rendering[c].window_end)
    #     else:
    #         windowed_sections[c] = array
    # # windowed_sections = { c: array for c, array in sections.items()}
    # # FIXME - put this back!
    # # windowed_sections = {
    # #     c: apply_window(array, rview.channel_rendering[c].window_start, rview.channel_rendering[c].window_end)
    # #     for c, array in sections.items()
    # # }

    # cmaps = [
    #     LinearSegmentedColormap.from_list('c', (crendering.colormap_start, crendering.colormap_end))
    #     for c, crendering in rview.channel_rendering.items()
    # ]

    # imarray, _, _, _ = multichannel_to_rgb(windowed_sections.values(), cmaps)

    # im = Image.fromarray(scale_to_uint8(imarray))
    
    # return im


# def render_2D_array(array, )